// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class UniswapLibrary__calculatePoolMintedAmountsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmount0Minted(): BigInt {
    return this.value0;
  }

  getAmount1Minted(): BigInt {
    return this.value1;
  }
}

export class UniswapLibrary__getAmountsForLiquidityResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmount0(): BigInt {
    return this.value0;
  }

  getAmount1(): BigInt {
    return this.value1;
  }
}

export class UniswapLibrary__getBufferTokenBalanceResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmount0(): BigInt {
    return this.value0;
  }

  getAmount1(): BigInt {
    return this.value1;
  }
}

export class UniswapLibrary__getBufferTokenBalanceInputTokenDetailsStruct extends ethereum.Tuple {
  get token0(): Address {
    return this[0].toAddress();
  }

  get token1(): Address {
    return this[1].toAddress();
  }

  get token0DecimalMultiplier(): BigInt {
    return this[2].toBigInt();
  }

  get token1DecimalMultiplier(): BigInt {
    return this[3].toBigInt();
  }

  get tokenDiffDecimalMultiplier(): BigInt {
    return this[4].toBigInt();
  }

  get token0Decimals(): i32 {
    return this[5].toI32();
  }

  get token1Decimals(): i32 {
    return this[6].toI32();
  }

  get rewardAmountRemainingToken0(): BigInt {
    return this[7].toBigInt();
  }

  get rewardAmountRemainingToken1(): BigInt {
    return this[8].toBigInt();
  }
}

export class UniswapLibrary extends ethereum.SmartContract {
  static bind(address: Address): UniswapLibrary {
    return new UniswapLibrary("UniswapLibrary", address);
  }

  calculatePoolMintedAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): UniswapLibrary__calculatePoolMintedAmountsResult {
    let result = super.call(
      "calculatePoolMintedAmounts",
      "calculatePoolMintedAmounts(uint256,uint256,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );

    return new UniswapLibrary__calculatePoolMintedAmountsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_calculatePoolMintedAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): ethereum.CallResult<UniswapLibrary__calculatePoolMintedAmountsResult> {
    let result = super.tryCall(
      "calculatePoolMintedAmounts",
      "calculatePoolMintedAmounts(uint256,uint256,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new UniswapLibrary__calculatePoolMintedAmountsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getAmountsForLiquidity(
    liquidity: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): UniswapLibrary__getAmountsForLiquidityResult {
    let result = super.call(
      "getAmountsForLiquidity",
      "getAmountsForLiquidity(uint128,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(liquidity),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );

    return new UniswapLibrary__getAmountsForLiquidityResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getAmountsForLiquidity(
    liquidity: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): ethereum.CallResult<UniswapLibrary__getAmountsForLiquidityResult> {
    let result = super.tryCall(
      "getAmountsForLiquidity",
      "getAmountsForLiquidity(uint128,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(liquidity),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new UniswapLibrary__getAmountsForLiquidityResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getBufferToken0Balance(
    token0: Address,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt,
    rewardAmountRemaining: BigInt
  ): BigInt {
    let result = super.call(
      "getBufferToken0Balance",
      "getBufferToken0Balance(address,uint8,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token0),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier),
        ethereum.Value.fromUnsignedBigInt(rewardAmountRemaining)
      ]
    );

    return result[0].toBigInt();
  }

  try_getBufferToken0Balance(
    token0: Address,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt,
    rewardAmountRemaining: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getBufferToken0Balance",
      "getBufferToken0Balance(address,uint8,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token0),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier),
        ethereum.Value.fromUnsignedBigInt(rewardAmountRemaining)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBufferToken1Balance(
    token1: Address,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt,
    rewardAmountRemaining: BigInt
  ): BigInt {
    let result = super.call(
      "getBufferToken1Balance",
      "getBufferToken1Balance(address,uint8,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token1),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier),
        ethereum.Value.fromUnsignedBigInt(rewardAmountRemaining)
      ]
    );

    return result[0].toBigInt();
  }

  try_getBufferToken1Balance(
    token1: Address,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt,
    rewardAmountRemaining: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getBufferToken1Balance",
      "getBufferToken1Balance(address,uint8,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token1),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier),
        ethereum.Value.fromUnsignedBigInt(rewardAmountRemaining)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBufferTokenBalance(
    tokenDetails: UniswapLibrary__getBufferTokenBalanceInputTokenDetailsStruct
  ): UniswapLibrary__getBufferTokenBalanceResult {
    let result = super.call(
      "getBufferTokenBalance",
      "getBufferTokenBalance((address,address,uint256,uint256,uint256,uint8,uint8,uint256,uint256)):(uint256,uint256)",
      [ethereum.Value.fromTuple(tokenDetails)]
    );

    return new UniswapLibrary__getBufferTokenBalanceResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getBufferTokenBalance(
    tokenDetails: UniswapLibrary__getBufferTokenBalanceInputTokenDetailsStruct
  ): ethereum.CallResult<UniswapLibrary__getBufferTokenBalanceResult> {
    let result = super.tryCall(
      "getBufferTokenBalance",
      "getBufferTokenBalance((address,address,uint256,uint256,uint256,uint8,uint8,uint256,uint256)):(uint256,uint256)",
      [ethereum.Value.fromTuple(tokenDetails)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new UniswapLibrary__getBufferTokenBalanceResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getLiquidityForAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): BigInt {
    let result = super.call(
      "getLiquidityForAmounts",
      "getLiquidityForAmounts(uint256,uint256,uint160,uint160,address):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );

    return result[0].toBigInt();
  }

  try_getLiquidityForAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiquidityForAmounts",
      "getLiquidityForAmounts(uint256,uint256,uint160,uint160,address):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolLiquidity(_pool: Address): BigInt {
    let result = super.call(
      "getPoolLiquidity",
      "getPoolLiquidity(address):(uint128)",
      [ethereum.Value.fromAddress(_pool)]
    );

    return result[0].toBigInt();
  }

  try_getPoolLiquidity(_pool: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPoolLiquidity",
      "getPoolLiquidity(address):(uint128)",
      [ethereum.Value.fromAddress(_pool)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolPrice(_pool: Address): BigInt {
    let result = super.call("getPoolPrice", "getPoolPrice(address):(uint160)", [
      ethereum.Value.fromAddress(_pool)
    ]);

    return result[0].toBigInt();
  }

  try_getPoolPrice(_pool: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPoolPrice",
      "getPoolPrice(address):(uint160)",
      [ethereum.Value.fromAddress(_pool)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolPriceWithDecimals(_pool: Address): BigInt {
    let result = super.call(
      "getPoolPriceWithDecimals",
      "getPoolPriceWithDecimals(address):(uint256)",
      [ethereum.Value.fromAddress(_pool)]
    );

    return result[0].toBigInt();
  }

  try_getPoolPriceWithDecimals(_pool: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPoolPriceWithDecimals",
      "getPoolPriceWithDecimals(address):(uint256)",
      [ethereum.Value.fromAddress(_pool)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPositionLiquidity(positionManager: Address, tokenId: BigInt): BigInt {
    let result = super.call(
      "getPositionLiquidity",
      "getPositionLiquidity(address,uint256):(uint128)",
      [
        ethereum.Value.fromAddress(positionManager),
        ethereum.Value.fromUnsignedBigInt(tokenId)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPositionLiquidity(
    positionManager: Address,
    tokenId: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPositionLiquidity",
      "getPositionLiquidity(address,uint256):(uint128)",
      [
        ethereum.Value.fromAddress(positionManager),
        ethereum.Value.fromUnsignedBigInt(tokenId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getSqrtRatio(tick: i32): BigInt {
    let result = super.call("getSqrtRatio", "getSqrtRatio(int24):(uint160)", [
      ethereum.Value.fromI32(tick)
    ]);

    return result[0].toBigInt();
  }

  try_getSqrtRatio(tick: i32): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getSqrtRatio",
      "getSqrtRatio(int24):(uint160)",
      [ethereum.Value.fromI32(tick)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTickFromPrice(price: BigInt): i32 {
    let result = super.call(
      "getTickFromPrice",
      "getTickFromPrice(uint160):(int24)",
      [ethereum.Value.fromUnsignedBigInt(price)]
    );

    return result[0].toI32();
  }

  try_getTickFromPrice(price: BigInt): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "getTickFromPrice",
      "getTickFromPrice(uint160):(int24)",
      [ethereum.Value.fromUnsignedBigInt(price)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getToken0AmountInNativeDecimals(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken0AmountInNativeDecimals",
      "getToken0AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken0AmountInNativeDecimals(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken0AmountInNativeDecimals",
      "getToken0AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getToken0AmountInWei(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken0AmountInWei",
      "getToken0AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken0AmountInWei(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken0AmountInWei",
      "getToken0AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getToken1AmountInNativeDecimals(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken1AmountInNativeDecimals",
      "getToken1AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken1AmountInNativeDecimals(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken1AmountInNativeDecimals",
      "getToken1AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getToken1AmountInWei(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken1AmountInWei",
      "getToken1AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken1AmountInWei(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken1AmountInWei",
      "getToken1AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subAbs(amount0: BigInt, amount1: BigInt): BigInt {
    let result = super.call("subAbs", "subAbs(uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount0),
      ethereum.Value.fromUnsignedBigInt(amount1)
    ]);

    return result[0].toBigInt();
  }

  try_subAbs(amount0: BigInt, amount1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("subAbs", "subAbs(uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount0),
      ethereum.Value.fromUnsignedBigInt(amount1)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subZero(amount0: BigInt, amount1: BigInt): BigInt {
    let result = super.call("subZero", "subZero(uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount0),
      ethereum.Value.fromUnsignedBigInt(amount1)
    ]);

    return result[0].toBigInt();
  }

  try_subZero(amount0: BigInt, amount1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "subZero",
      "subZero(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}
