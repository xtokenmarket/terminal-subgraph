// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class UniswapLibrary__calculatePoolMintedAmountsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class UniswapLibrary__getAmountsForLiquidityResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class UniswapLibrary__getBufferTokenBalanceResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class UniswapLibrary__getBufferTokenBalanceInputTokenDetailsStruct extends ethereum.Tuple {
  get token0(): Address {
    return this[0].toAddress();
  }

  get token1(): Address {
    return this[1].toAddress();
  }

  get token0DecimalMultiplier(): BigInt {
    return this[2].toBigInt();
  }

  get token1DecimalMultiplier(): BigInt {
    return this[3].toBigInt();
  }

  get token0Decimals(): i32 {
    return this[4].toI32();
  }

  get token1Decimals(): i32 {
    return this[5].toI32();
  }

  get rewardAmountRemainingToken0(): BigInt {
    return this[6].toBigInt();
  }

  get rewardAmountRemainingToken1(): BigInt {
    return this[7].toBigInt();
  }
}

export class UniswapLibrary extends ethereum.SmartContract {
  static bind(address: Address): UniswapLibrary {
    return new UniswapLibrary("UniswapLibrary", address);
  }

  calculatePoolMintedAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): UniswapLibrary__calculatePoolMintedAmountsResult {
    let result = super.call(
      "calculatePoolMintedAmounts",
      "calculatePoolMintedAmounts(uint256,uint256,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );

    return new UniswapLibrary__calculatePoolMintedAmountsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_calculatePoolMintedAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): ethereum.CallResult<UniswapLibrary__calculatePoolMintedAmountsResult> {
    let result = super.tryCall(
      "calculatePoolMintedAmounts",
      "calculatePoolMintedAmounts(uint256,uint256,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new UniswapLibrary__calculatePoolMintedAmountsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getAmountInAsset0Terms(
    amount: BigInt,
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getAmountInAsset0Terms",
      "getAmountInAsset0Terms(uint256,address,uint32,uint8,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getAmountInAsset0Terms(
    amount: BigInt,
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAmountInAsset0Terms",
      "getAmountInAsset0Terms(uint256,address,uint32,uint8,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAmountInAsset1Terms(
    amount: BigInt,
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getAmountInAsset1Terms",
      "getAmountInAsset1Terms(uint256,address,uint32,uint8,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getAmountInAsset1Terms(
    amount: BigInt,
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAmountInAsset1Terms",
      "getAmountInAsset1Terms(uint256,address,uint32,uint8,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAmountsForLiquidity(
    liquidity: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): UniswapLibrary__getAmountsForLiquidityResult {
    let result = super.call(
      "getAmountsForLiquidity",
      "getAmountsForLiquidity(uint128,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(liquidity),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );

    return new UniswapLibrary__getAmountsForLiquidityResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getAmountsForLiquidity(
    liquidity: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): ethereum.CallResult<UniswapLibrary__getAmountsForLiquidityResult> {
    let result = super.tryCall(
      "getAmountsForLiquidity",
      "getAmountsForLiquidity(uint128,uint160,uint160,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(liquidity),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new UniswapLibrary__getAmountsForLiquidityResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getAsset0Price(
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getAsset0Price",
      "getAsset0Price(address,uint32,uint8,uint8,uint256):(int128)",
      [
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getAsset0Price(
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAsset0Price",
      "getAsset0Price(address,uint32,uint8,uint8,uint256):(int128)",
      [
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAsset1Price(
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getAsset1Price",
      "getAsset1Price(address,uint32,uint8,uint8,uint256):(int128)",
      [
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getAsset1Price(
    pool: Address,
    twapPeriod: BigInt,
    token0Decimals: i32,
    token1Decimals: i32,
    tokenDiffDecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAsset1Price",
      "getAsset1Price(address,uint32,uint8,uint8,uint256):(int128)",
      [
        ethereum.Value.fromAddress(pool),
        ethereum.Value.fromUnsignedBigInt(twapPeriod),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(tokenDiffDecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBufferBalance(): BigInt {
    let result = super.call(
      "getBufferBalance",
      "getBufferBalance():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getBufferBalance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getBufferBalance",
      "getBufferBalance():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBufferTokenBalance(
    tokenDetails: UniswapLibrary__getBufferTokenBalanceInputTokenDetailsStruct
  ): UniswapLibrary__getBufferTokenBalanceResult {
    let result = super.call(
      "getBufferTokenBalance",
      "getBufferTokenBalance((address,address,uint256,uint256,uint8,uint8,uint256,uint256)):(uint256,uint256)",
      [ethereum.Value.fromTuple(tokenDetails)]
    );

    return new UniswapLibrary__getBufferTokenBalanceResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getBufferTokenBalance(
    tokenDetails: UniswapLibrary__getBufferTokenBalanceInputTokenDetailsStruct
  ): ethereum.CallResult<UniswapLibrary__getBufferTokenBalanceResult> {
    let result = super.tryCall(
      "getBufferTokenBalance",
      "getBufferTokenBalance((address,address,uint256,uint256,uint8,uint8,uint256,uint256)):(uint256,uint256)",
      [ethereum.Value.fromTuple(tokenDetails)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new UniswapLibrary__getBufferTokenBalanceResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getLiquidityForAmount0(
    priceLower: BigInt,
    priceUpper: BigInt,
    amount0: BigInt
  ): BigInt {
    let result = super.call(
      "getLiquidityForAmount0",
      "getLiquidityForAmount0(uint160,uint160,uint256):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromUnsignedBigInt(amount0)
      ]
    );

    return result[0].toBigInt();
  }

  try_getLiquidityForAmount0(
    priceLower: BigInt,
    priceUpper: BigInt,
    amount0: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiquidityForAmount0",
      "getLiquidityForAmount0(uint160,uint160,uint256):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromUnsignedBigInt(amount0)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLiquidityForAmount1(
    priceLower: BigInt,
    priceUpper: BigInt,
    amount1: BigInt
  ): BigInt {
    let result = super.call(
      "getLiquidityForAmount1",
      "getLiquidityForAmount1(uint160,uint160,uint256):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromUnsignedBigInt(amount1)
      ]
    );

    return result[0].toBigInt();
  }

  try_getLiquidityForAmount1(
    priceLower: BigInt,
    priceUpper: BigInt,
    amount1: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiquidityForAmount1",
      "getLiquidityForAmount1(uint160,uint160,uint256):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromUnsignedBigInt(amount1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLiquidityForAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): BigInt {
    let result = super.call(
      "getLiquidityForAmounts",
      "getLiquidityForAmounts(uint256,uint256,uint160,uint160,address):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );

    return result[0].toBigInt();
  }

  try_getLiquidityForAmounts(
    amount0: BigInt,
    amount1: BigInt,
    priceLower: BigInt,
    priceUpper: BigInt,
    pool: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiquidityForAmounts",
      "getLiquidityForAmounts(uint256,uint256,uint160,uint160,address):(uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1),
        ethereum.Value.fromUnsignedBigInt(priceLower),
        ethereum.Value.fromUnsignedBigInt(priceUpper),
        ethereum.Value.fromAddress(pool)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNav(): BigInt {
    let result = super.call("getNav", "getNav():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getNav(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getNav", "getNav():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolLiquidity(_pool: Address): BigInt {
    let result = super.call(
      "getPoolLiquidity",
      "getPoolLiquidity(address):(uint128)",
      [ethereum.Value.fromAddress(_pool)]
    );

    return result[0].toBigInt();
  }

  try_getPoolLiquidity(_pool: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPoolLiquidity",
      "getPoolLiquidity(address):(uint128)",
      [ethereum.Value.fromAddress(_pool)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolPrice(_pool: Address): BigInt {
    let result = super.call("getPoolPrice", "getPoolPrice(address):(uint160)", [
      ethereum.Value.fromAddress(_pool)
    ]);

    return result[0].toBigInt();
  }

  try_getPoolPrice(_pool: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPoolPrice",
      "getPoolPrice(address):(uint160)",
      [ethereum.Value.fromAddress(_pool)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolPriceWithDecimals(
    _pool: Address,
    token0Decimals: i32,
    token1Decimals: i32
  ): BigInt {
    let result = super.call(
      "getPoolPriceWithDecimals",
      "getPoolPriceWithDecimals(address,uint8,uint8):(uint256)",
      [
        ethereum.Value.fromAddress(_pool),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals))
      ]
    );

    return result[0].toBigInt();
  }

  try_getPoolPriceWithDecimals(
    _pool: Address,
    token0Decimals: i32,
    token1Decimals: i32
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPoolPriceWithDecimals",
      "getPoolPriceWithDecimals(address,uint8,uint8):(uint256)",
      [
        ethereum.Value.fromAddress(_pool),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPositionLiquidity(positionManager: Address, tokenId: BigInt): BigInt {
    let result = super.call(
      "getPositionLiquidity",
      "getPositionLiquidity(address,uint256):(uint128)",
      [
        ethereum.Value.fromAddress(positionManager),
        ethereum.Value.fromUnsignedBigInt(tokenId)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPositionLiquidity(
    positionManager: Address,
    tokenId: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPositionLiquidity",
      "getPositionLiquidity(address,uint256):(uint128)",
      [
        ethereum.Value.fromAddress(positionManager),
        ethereum.Value.fromUnsignedBigInt(tokenId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getSqrtRatio(tick: i32): BigInt {
    let result = super.call("getSqrtRatio", "getSqrtRatio(int24):(uint160)", [
      ethereum.Value.fromI32(tick)
    ]);

    return result[0].toBigInt();
  }

  try_getSqrtRatio(tick: i32): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getSqrtRatio",
      "getSqrtRatio(int24):(uint160)",
      [ethereum.Value.fromI32(tick)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getStakedBalance(): BigInt {
    let result = super.call(
      "getStakedBalance",
      "getStakedBalance():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getStakedBalance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getStakedBalance",
      "getStakedBalance():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTickFromPrice(price: BigInt): i32 {
    let result = super.call(
      "getTickFromPrice",
      "getTickFromPrice(uint160):(int24)",
      [ethereum.Value.fromUnsignedBigInt(price)]
    );

    return result[0].toI32();
  }

  try_getTickFromPrice(price: BigInt): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "getTickFromPrice",
      "getTickFromPrice(uint160):(int24)",
      [ethereum.Value.fromUnsignedBigInt(price)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getToken0AmountInNativeDecimals(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken0AmountInNativeDecimals",
      "getToken0AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken0AmountInNativeDecimals(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken0AmountInNativeDecimals",
      "getToken0AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getToken0AmountInWei(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken0AmountInWei",
      "getToken0AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken0AmountInWei(
    amount: BigInt,
    token0Decimals: i32,
    token0DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken0AmountInWei",
      "getToken0AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token0Decimals)),
        ethereum.Value.fromUnsignedBigInt(token0DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getToken1AmountInNativeDecimals(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken1AmountInNativeDecimals",
      "getToken1AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken1AmountInNativeDecimals(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken1AmountInNativeDecimals",
      "getToken1AmountInNativeDecimals(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getToken1AmountInWei(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): BigInt {
    let result = super.call(
      "getToken1AmountInWei",
      "getToken1AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );

    return result[0].toBigInt();
  }

  try_getToken1AmountInWei(
    amount: BigInt,
    token1Decimals: i32,
    token1DecimalMultiplier: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getToken1AmountInWei",
      "getToken1AmountInWei(uint256,uint8,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(token1Decimals)),
        ethereum.Value.fromUnsignedBigInt(token1DecimalMultiplier)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subAbs(amount0: BigInt, amount1: BigInt): BigInt {
    let result = super.call("subAbs", "subAbs(uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount0),
      ethereum.Value.fromUnsignedBigInt(amount1)
    ]);

    return result[0].toBigInt();
  }

  try_subAbs(amount0: BigInt, amount1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("subAbs", "subAbs(uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount0),
      ethereum.Value.fromUnsignedBigInt(amount1)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subZero(amount0: BigInt, amount1: BigInt): BigInt {
    let result = super.call("subZero", "subZero(uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount0),
      ethereum.Value.fromUnsignedBigInt(amount1)
    ]);

    return result[0].toBigInt();
  }

  try_subZero(amount0: BigInt, amount1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "subZero",
      "subZero(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount0),
        ethereum.Value.fromUnsignedBigInt(amount1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}
